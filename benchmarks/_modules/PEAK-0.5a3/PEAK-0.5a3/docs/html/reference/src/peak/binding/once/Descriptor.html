<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
          "http://www.w3.org/TR/html40/loose.dtd">

<html>
         
  <head>
    <title>Class: Descriptor</title>
  </head>

  <body bgcolor="#ffffff">

        <p><i><a href="../../../../index.html">Table of Contents</a></i></p>
        
        <table border="0" cellpadding="5" cellspacing="0" width="100%">
        <tr>
            <th rowspan="2"
                valign="top"
                align="left"
                width="10%"
                bgcolor="#88bbee"><font color="#000000">Class: Descriptor</font>
            </th>
            <th bgcolor="#88bbee"
                width="90%"
                align="right"><font color="#000000">./src/peak/binding/once.py</font>
            </th>
        </tr>
        <tr>
        <td>
        
<h3>Attribute descriptor with lazy initialization and caching</h3>
<p>    A <code>Descriptor</code> (or subclass) instance is a Python attribute descriptor,
    similar to the ones created using the Python <code>property</code> built-in type.
    However, where <code>property</code> instances invoke a function on every access to
    the attribute, <code>binding.Descriptor</code> instances only call their
    <code>computeValue()</code> method once, caching the result in the containing object's
    dictionary.  Thereafter, the value in the dictionary is reused, instead of
    calling the function each time.  If the attribute is deleted (e.g. via
    <code>del anObj.anAttr</code>) or the value is cleared from the dictionary, the
    <code>computeValue()</code> method will be called again, the next time that the
    attribute is retrieved.</p>
<p>    Because the instance dictionary is used to store the attribute value, a
    <code>Descriptor</code> needs to know its name, so that it knows what key to store its
    value under.  Unfortunately, Python does not provide a way for descriptors
    to know what name(s) they are accessible under in a class, so you must
    explicitly provide an <code>attrName</code> value, either as a constructor keyword
    argument, or by defining it in a subclass.  Many <code>Descriptor</code> subclasses
    have the ability to guess or detect what <code>attrName</code> should be used, but you
    must still explicitly provide it if they are unable to do so automatically.
    Failure to supply a correct <code>attrName</code> will result in a <code>TypeError</code> when
    the attribute is used.</p>
<p>    <code>Descriptor</code> instances have the following attributes which may be set by
    keyword arguments to the class' constructor:<dl>
<dt>        <code>attrName</code></dt>
<dd>sets the name which the descriptor will use to get/set
        its value in the instance dictionary.  Ordinarily this should be the
        same as the name given to the descriptor in its containing class, but
        you may occasionally wish it to be something else.</dd>
<dt>        <code>computeValue(obj, instDict, attrName)</code></dt>
<dd>a function that will be
        called whenever the attribute is accessed and no value for the
        attribute is present in the object's instance dictionary.  The function
        will be passed three arguments: the object that owns the attribute, the
        object's instance dictionary, and the descriptor's <code>attrName</code>.<p>         The value returned will be treated as the attribute's value.  It will
         also be cached in the object's instance dictionary to avoid repeat
         calls, unless the descriptor's <code>noCache</code> attribute is <code>True</code>.</p>
<p>         Note that the default implementation of <code>computeValue()</code> simply raises
         an <code>AttributeError</code>.  Also note that the call signature of
         <code>computeValue()</code> is the same as that of <code>binding.IRecipe</code>.  That is,
         any object that provides <code>IRecipe</code> may be used as a <code>computeValue</code>
         attribute.  <code>Descriptor</code> does not perform any adaptation, however, so
         if your desired object must be adapted to <code>IRecipe</code>, you should do so
         before assigning it to the <code>computeValue</code> attribute.</p>
</dd>
<dt>        <code>noCache</code></dt>
<dd>if set to <code>True</code>, the descriptor will not cache its
        <code>computeValue()</code> results in the owning object's instance dictionary.
        This makes the descriptor's behavior more similar to the Python
        <code>property</code> type.  But, <code>computeValue()</code> will not be called when the
        attribute is currently set (i.e., a value is in the object's instance
        dictionary under <code>attrName</code>), so the behavior is still quite different
        from the <code>property</code> type.</dd>
<dt>        <code>onSet(obj, attrName, value)</code></dt>
<dd>a function that will be called
        whenever the attribute is set, or when the result of <code>computeValue()</code>
        is to be cached.  The function will be passed three arguments: the
        object that owns the attribute, the descriptor's <code>attrName</code>, and the
        <code>value</code> that is to be set.  The function may return the passed-in
        value, or change it by returning a different value.  To prevent the
        value from being set, the function should raise an exception.  If you
        do not set this attribute, its default implementation simply returns
        the value unmodified.</dd>
<dt>        <code>ofClass(attrName, klass)</code></dt>
<dd>a function that will be called whenever
        the descriptor is retrieved from its class.  The default implementation
        simply returns the descriptor.</dd>
<dt>        <code>permissionNeeded</code></dt>
<dd>a <code>peak.security.IAbstractPermission</code>, or <code>None</code>.
        This is a convenience feature for use with the <code>peak.security</code> package.</dd>
</dl>
</p>
<p>    You can override the methods described above in subclasses.  Keep in mind,
    however, that you will then need to add a <code>self</code> parameter in addition to
    the ones described above.  The <code>self</code> argument will refer to the
    <code>Descriptor</code> instance.</p>
<p>    The <code>Descriptor</code> class is rarely used directly; normally you will use one
    of its subclasses, which have many additional features for more convenient
    use.  However, many of those subclasses themselves use <code>Descriptor</code>
    instances as part of their definition.  That's why this exists as a
    separate base class: to make it possible to use descriptors as part of the
    definition of descriptor classes.</p>
<table border="0" cellpadding="5" cellspacing="0" width="100%">

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="Base Classes">Base Classes</a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        
BaseDescriptor<br>

</td></tr>
</table>
<table border="0" cellpadding="5" cellspacing="0" width="100%">

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="Methods">Methods</a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        
<a href="#__init__">__init__</a><br>


        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="__init__"></a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">__init__&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        <font color="#000088"><pre>
__init__ ( self,  **kw )

</pre></font>

<h3>Create a descriptor from keyword arguments</h3>
<p>        You may pass any keyword arguments, as long as they represent existing
        attributes defined by the <code>Descriptor</code> class (or subclass, if
        this constructor is used by the subclass).</p>
<table border="0" cellpadding="5" cellspacing="0" width="100%">

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="Exceptions">Exceptions</a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        
TypeError("%r has no keyword argument %r" %( klass, k ) )<br>

</td></tr>
</table>
</td></tr>
</td></tr>
</table>

        </td>
        </tr>
        </table>

        <hr>

        <p><i><a href="../../../../index.html">Table of Contents</a></i></p>

        <font size="-2"><i>This document was automatically generated
        on Tue Feb 17 19:55:38 2004 by
        <a href="http://happydoc.sourceforge.net">HappyDoc</a> version
        2.1</i></font>
        
        </body>
        </html>
        