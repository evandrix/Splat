[13/3/12]
-----------------------------------------------------------------------------
Compare both strings & int/float
    [...
        (LOAD_FAST, 'one'),
        (LOAD_FAST, 2),
        (COMPARE_OP, '==')
    ...]
- mutate assignments, branches in module under test, and run against generated test suite,
the larger percentage of test failures, the better quality of the generated test suite
- assume Python code not compiled optimised (where asserts are removed in bytecode)
- excludes Python C extension modules

CALL_FUNCTION(argc)Â¶
Calls a function. The low byte of argc indicates the number of positional parameters, the high byte the number of keyword parameters. On the stack, the opcode finds the keyword parameters first. For each keyword argument, the value is on top of the key. Below the keyword parameters, the positional parameters are on the stack, with the right-most parameter on top. Below the parameters, the function object to call is on the stack. Pops all function arguments, and the function itself off the stack, and pushes the return value.

@ http://docs.python.org/dev/reference/executionmodel.html
"block" A piece of Python program text that is executed as a unit. The following are blocks: a module, a function body and a class definition.

=============================================================================
[7/3/12] callable() vs. hasattr(obj, "__call__")
-----------------------------------------------------------------------------
If you use the python builtin "callable" instead of "hasattr(type_func, 
'__call__')", then classes can be used as argument types, ie.
class A:
    pass
callable(A) = True
hasattr(A, "__call__") = False

Example:
>>> class P(property):
...   def __get__(self, obj, cls):
...     1/0
>>> class C(object):
...   __call__ = P()
>>> c = C()
>>> callable(c)
True
>>> hasattr(c, "__call__")
False
>>> c.__call__
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in __get__
ZeroDivisionError: integer division or modulo by zero

The reason is that hasattr() really calls getattr() and then discards the result / catches any exception, while callable() only examines the type's structure (callable() is lower level).

built-in function is easier to read, better performance than attribute lookup, ie.
$ python -m timeit "hasattr(None, '__call__')"
1000000 loops, best of 3: 1.22 usec per loop
$ ./python -m timeit "callable(None)"
10000000 loops, best of 3: 0.176 usec per loop

$ python -m timeit "hasattr(str, '__call__')"
1000000 loops, best of 3: 0.326 usec per loop
$ python -m timeit "callable(str)"
1000000 loops, best of 3: 0.195 usec per loop
_____________________________________________________________________________
