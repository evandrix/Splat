<link rel="stylesheet" type="text/css" href="http://google-code-prettify.googlecode.com/svn/trunk/src/prettify.css" />
<script type="text/javascript" src="http://google-code-prettify.googlecode.com/svn/trunk/src/prettify.js"></script>
<style>
    pre {
        padding: 5px;
        font-family: Consolas, Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace, serif;
        margin-bottom: 10px;
        background-color: #EEE;
        overflow: auto;
        width: auto;
        width: 650px !ie7;
        padding-bottom: 20px !ie7;
        max-height: 600px;
    }
</style>

<body onload="prettyPrint()">
<summary type="html"><p><strong>Function argument unpacking</strong></p>

<p>You can unpack a list or a dictionary as function arguments using <code>*</code> and <code>**</code>.</p>

<p>For example:</p>

<pre class="prettyprint"><code>def draw_point(x, y):
# do some magic

point_foo = (3, 4)
point_bar = {&#39;y&#39;: 3, &#39;x&#39;: 2}

draw_point(*point_foo)
draw_point(**point_bar)
</code></pre>

<p>Very useful shortcut since lists, tuples and dicts are widely used as containers.</p>
</summary>
<summary type="html"><p><strong>Braces</strong></p><p>If you don&#39;t like using whitespace to denote scopes, you can use the C-style {} by issuing:</p>

<pre class="prettyprint"><code>from __future__ import braces
</code></pre>
</summary>
<summary type="html"><p><strong>Chaining comparison operators</strong></p>

<pre class="prettyprint"><code>>>> x = 5
>>> 1 &lt; x &lt; 10
True
>>> 10 &lt; x &lt; 20 
False
>>> x &lt; 10 &lt; x*10 &lt; 100
True
>>> 10 > x &lt;= 9
True
>>> 5 == x > 4
True
</code></pre>

<p>In case you&#39;re thinking it&#39;s doing <code>1 &lt; x</code>, which comes out as <code>True</code>, and then comparing <code>True &lt; 10</code>, which is also <code>True</code>, then no, that&#39;s really not what happens (see the last example.) It&#39;s really translating into <code>1 &lt; x and x &lt; 10</code>, and <code>x &lt; 10 and 10 &lt; x * 10 and x*10 &lt; 100</code>, but with less typing and each term is only evaluated once.</p>
</summary>
<summary type="html"><p><strong>Decorators</strong></p>

<p><a href='http://docs.python.org/ref/function.html#tok-decorators' rel='nofollow'>Decorators</a> allow to wrap a function or method in another function that can add functionality, modify arguments or results, etc. You write decorators one line above the function definition, beginning with an 'at' sign (@).</p>

<p>Example shows a <code>print_args</code> decorator that prints the decorated function&#39;s arguments before calling it:</p>

<pre class="prettyprint"><code>>>> def print_args(function):
>>>     def wrapper(*args, **kwargs):
>>>         print &#39;Arguments:&#39;, args, kwargs
>>>         return function(*args, **kwargs)
>>>     return wrapper

>>> @print_args
>>> def write(text):
>>>     print text

>>> write(&#39;foo&#39;)
Arguments: (&#39;foo&#39;,) {}
foo
</code></pre>
</summary>
<summary type="html"><p><strong>Be careful with mutable default arguments</strong></p>

<pre class="prettyprint"><code>>>> def foo(x=[]):
...     x.append(1)
...     print x
... 
>>> foo()
[1]
>>> foo()
[1, 1]
>>> foo()
[1, 1, 1]
</code></pre>

<p>Instead, you should use a sentinel value denoting 'not given' and replace with the mutable you&#39;d like as default:</p>

<pre class="prettyprint"><code>>>> def foo(x=None):
...     if x is None:
...         x = []
...     x.append(1)
...     print x
>>> foo()
[1]
>>> foo()
[1]
</code></pre>
</summary>
<summary type="html"><p><strong>Descriptors</strong></p>

<p>They&#39;re the magic behind a whole bunch of core Python features. </p>

<p>When you use dotted access to look up a member (eg, x.y), Python first looks for the member in the instance dictionary. If it&#39;s not found, it looks for it in the class dictionary. If it finds it in the class dictionary, and the object implements the descriptor protocol, instead of just returning it, Python executes it. A descriptor is any class that implements the <code>__get__</code>, <code>__set__</code>, or <code>__del__</code> methods.</p>

<p>Here&#39;s how you&#39;d implement your own (read-only) version of property using descriptors:</p>

<pre class="prettyprint"><code>class Property(object):
def __init__(self, fget):
self.fget = fget

def __get__(self, obj, type):
if obj is None:
    return self
return self.fget(obj)
</code></pre>

<p>and you&#39;d use it just like the built-in property():</p>

<pre class="prettyprint"><code>class MyClass(object):
@Property
def foo(self):
return 'Foo!'
</code></pre>

<p>Descriptors are used in Python to implement properties, bound methods, static methods, class methods and slots, amongst other things. Understanding them makes it easy to see why a lot of things that previously looked like Python &#39;quirks&#39; are the way they are.</p>

<p>Raymond Hettinger has <a href='http://users.rcn.com/python/download/Descriptor.htm' rel='nofollow'>an excellent tutorial</a> that does a much better job of describing them than I do.</p>
</summary>
<summary type="html"><p>Too lazy to initialize every field in a dictionary? No problem:</p>

<p>In Python > 2.3:</p>

<pre class="prettyprint"><code>from collections import defaultdict
</code></pre>

<p>In Python &lt;= 2.3:</p>

<pre class="prettyprint"><code>def defaultdict(type_):
class Dict(dict):
def __getitem__(self, key):
    return self.setdefault(key, type_())
return Dict()
</code></pre>

<p>In any version:</p>

<pre class="prettyprint"><code>d = defaultdict(list)
for stuff in lots_of_stuff:
d[stuff.name].append(stuff)
</code></pre>

<p><strong>UPDATE:</strong></p>

<p>Thanks <a href='http://stackoverflow.com/users/69707/ken-arnold'>Ken Arnold</a>. I reimplemented a more sophisticated version of defaultdict. It should behave exactly as <a href='http://docs.python.org/library/collections.html#collections.defaultdict' rel='nofollow'>the one in the standard library</a>.</p>

<pre class="prettyprint"><code>def defaultdict(default_factory, *args, **kw):                              

class defaultdict(dict):

def __missing__(self, key):
    if default_factory is None:
        raise KeyError(key)
    return self.setdefault(key, default_factory())

def __getitem__(self, key):
    try:
        return dict.__getitem__(self, key)
    except KeyError:
        return self.__missing__(key)

return defaultdict(*args, **kw)
</code></pre>
</summary>
<summary type="html"><p><a href='http://docs.python.org/lib/module-doctest.html' rel='nofollow'>Doctest</a>: documentation and unit-testing at the same time. </p>

<p>Example extracted from the Python documentation:</p>

<pre class="prettyprint"><code>def factorial(n):
    '''Return the factorial of n, an exact integer >= 0.

    If the result is small enough to fit in an int, return an int.
    Else return a long.

    >>> [factorial(n) for n in range(6)]
    [1, 1, 2, 6, 24, 120]
    >>> factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: n must be >= 0

    Factorials of floats are OK, but the float must be an exact integer:
    '''

    import math
    if not n >= 0:
        raise ValueError('n must be >= 0')
    if math.floor(n) != n:
        raise ValueError('n must be exact integer')
    if n+1 == n:  # catch a value like 1e300
        raise OverflowError('n too large')
    result = 1
    factor = 2
    while factor &lt;= n:
        result *= factor
        factor += 1
    return result

def _test():
    import doctest
    doctest.testmod()    

if __name__ == '__main__':
    _test()
</code></pre>
</summary>
<summary type="html"><p>Python&#39;s advanced slicing operation has a barely known syntax element, the ellipsis:</p>

<pre class="prettyprint"><code>>>> class C(object):
...  def __getitem__(self, item):
...   return item
... 
>>> C()[1:2, ..., 3]
(slice(1, 2, None), Ellipsis, 3)
</code></pre>

<p>Unfortunately it&#39;s barely useful as the ellipsis is only supported if tuples are involved.</p>
</summary>
<summary type="html"><p><strong>Creating enums</strong></p>

<p>In Python, you can do this to quickly create an enumeration:</p>

<pre class="prettyprint"><code>>>> FOO, BAR, BAZ = range(3)
>>> FOO
0
</code></pre>

<p>But the 'enums' don&#39;t have to have integer values. You can even do this:</p>

<pre class="prettyprint"><code>class Colors(object):
    RED, GREEN, BLUE, YELLOW = (255,0,0), (0,255,0), (0,0,255), (0,255,255)

#now Colors.RED is a 3-tuple that returns the 24-bit 8bpp RGB 
#value for saturated red
</code></pre>
</summary>
<summary type="html"><p>The for...else syntax (see <a href='http://docs.python.org/ref/for.html' rel='nofollow'>http://docs.python.org/ref/for.html</a> )</p>

<pre class="prettyprint"><code>for i in foo:
    if i == 0:
        break
else:
    print('i was never 0')
</code></pre>

<p>The 'else' block will be normally executed at the end of the for loop, unless the break is called.</p>

<p>The above code could be emulated as follows:</p>

<pre class="prettyprint"><code>found = False
for i in foo:
    if i == 0:
        found = True
        break
if not found: 
    print('i was never 0')
</code></pre>
</summary>
<summary type="html"><p><strong>iter() can take a callable argument</strong></p>

<p>For instance:</p>

<pre class="prettyprint"><code>def seek_next_line(f):
    for c in iter(lambda: f.read(1),&#39;\n&#39;):
        pass
</code></pre>

<p>The <code>iter(callable, until_value)</code> function repeatedly calls <code>callable</code> and yields its result until <code>until_value</code> is returned. </p>
</summary>
<summary type="html"><p>Nested list comprehensions and generator expressions:</p>

<pre class="prettyprint"><code>[(i,j) for i in range(3) for j in range(i) ]    
((i,j) for i in range(4) for j in range(i) )
</code></pre>

<p>These can replace huge chunks of nested-loop code.</p>
</summary>
<summary type="html"><p>Tuple unpacking in for loops, list comprehensions and generator expressions:</p>

<pre class="prettyprint"><code>>>> l=[(1,2),(3,4)]
>>> [a+b for a,b in l ] 
[3,7]
</code></pre>

<p>Useful in this idiom for iterating over (key,data) pairs in dictionaries:</p>

<pre class="prettyprint"><code>d = { &#39;x&#39;:&#39;y&#39;, &#39;f&#39;:&#39;e&#39;}
for name, value in d.items():  # one can also use iteritems()
print 'name:%s, value:%s' % (name,value)
</code></pre>

<p>prints:</p>

<pre class="prettyprint"><code>name:x, value:y
name:f, value:e
</code></pre>
</summary>
<summary type="html"><p><strong>Functional support.</strong></p>

<p>Generators and generator expressions, specifically.</p>

<p>Ruby made this mainstream again, but Python can do it just as well.  Not as ubiquitous in the libraries as in Ruby, which is too bad, but I like the syntax better, it&#39;s simpler.</p>

<p>Because they&#39;re not as ubiquitous, I don&#39;t see as many examples out there on why they&#39;re useful, but they&#39;ve allowed me to write cleaner, more efficient code.</p>
</summary>
<summary type="html"><p><strong>The Zen of Python</strong></p>

<pre class="prettyprint"><code>>>> import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren&#39;t special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you&#39;re Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it&#39;s a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let&#39;s do more of those!
</code></pre>
</summary>
<summary type="html"><p><strong>In-place value swapping</strong></p>

<pre class="prettyprint"><code>>>> a = 10
>>> b = 5
>>> a, b
(10, 5)

>>> a, b = b, a
>>> a, b
(5, 10)
</code></pre>

<p>The right-hand side of the assignment is an expression that creates a new tuple. The left-hand side of the assignment immediately unpacks that (unreferenced) tuple to the names <code>a</code> and <code>b</code>.</p>

<p>After the assignment, the new tuple is unreferenced and marked for garbage collection, and the values bound to <code>a</code> and <code>b</code> have been swapped.</p>

<p>As noted in the <a href='http://docs.python.org/tutorial/datastructures.html#tuples-and-sequences' rel='nofollow'>Python tutorial section on data structures</a>,</p>

<blockquote>
  <p>Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.</p>
</blockquote>
</summary>
<summary type="html"><p>The step argument in slice operators. For example:</p>

<pre class="prettyprint"><code>a = [1,2,3,4,5]
>>> a[::2]  # iterate over the whole list in 2-increments
[1,3,5]
</code></pre>

<p>The special case <code>x[::-1]</code> is a useful idiom for &#39;x reversed&#39;.</p>

<pre class="prettyprint"><code>>>> a[::-1]
[5,4,3,2,1]
</code></pre>
</summary>
<summary type="html"><p>From 2.5 onwards dicts have a special method <code>__missing__</code> that is invoked for missing items:</p>

<pre class="prettyprint"><code>>>> class MyDict(dict):
...  def __missing__(self, key):
...   self[key] = rv = []
...   return rv
... 
>>> m = MyDict()
>>> m['foo'].append(1)
>>> m['foo'].append(2)
>>> dict(m)
{&#39;foo&#39;: [1, 2]}
</code></pre>

<p>There is also a dict subclass in <code>collections</code> called <code>defaultdict</code> that does pretty much the same but calls a function without arguments for not existing items:</p>

<pre class="prettyprint"><code>>>> from collections import defaultdict
>>> m = defaultdict(list)
>>> m['foo'].append(1)
>>> m['foo'].append(2)
>>> dict(m)
{&#39;foo&#39;: [1, 2]}
</code></pre>

<p>I recommend converting such dicts to regular dicts before passing them to functions that don&#39;t expect such subclasses.  A lot of code uses <code>d[a_key]</code> and catches KeyErrors to check if an item exists which would add a new item to the dict.</p>
</summary>
<summary type="html"><p><strong>Readable regular expressions</strong></p>

<p>In Python you can split a regular expression over multiple lines, name your matches and insert comments.</p>

<p>Example verbose syntax (from <a href='http://diveintopython.org/regular_expressions/index.html' rel='nofollow'>Dive into Python</a>):</p>

<pre class="prettyprint"><code>>>> pattern = '''
... ^                   # beginning of string
... M{0,4}              # thousands - 0 to 4 M&#39;s
... (CM|CD|D?C{0,3})    # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 C&#39;s),
...                     #            or 500-800 (D, followed by 0 to 3 C&#39;s)
... (XC|XL|L?X{0,3})    # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 X&#39;s),
...                     #        or 50-80 (L, followed by 0 to 3 X&#39;s)
... (IX|IV|V?I{0,3})    # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 I&#39;s),
...                     #        or 5-8 (V, followed by 0 to 3 I&#39;s)
... $                   # end of string
... '''
>>> re.search(pattern, &#39;M&#39;, re.VERBOSE)
</code></pre>

<p>Example naming matches (from <a href='http://www.amk.ca/python/howto/regex/' rel='nofollow'>Regular Expression HOWTO</a>)</p>

<pre class="prettyprint"><code>>>> p = re.compile(r&#39;(?P&lt;word>\b\w+\b)&#39;)
>>> m = p.search( &#39;(((( Lots of punctuation )))&#39; )
>>> m.group(&#39;word&#39;)
&#39;Lots&#39;
</code></pre>

<p>You can also verbosely write a regex without using <code>re.VERBOSE</code> thanks to string literal concatenation.</p>

<pre class="prettyprint"><code>>>> pattern = (
...     '^'                 # beginning of string
...     'M{0,4}'            # thousands - 0 to 4 M&#39;s
...     '(CM|CD|D?C{0,3})'  # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 C&#39;s),
...                         #            or 500-800 (D, followed by 0 to 3 C&#39;s)
...     '(XC|XL|L?X{0,3})'  # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 X&#39;s),
...                         #        or 50-80 (L, followed by 0 to 3 X&#39;s)
...     '(IX|IV|V?I{0,3})'  # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 I&#39;s),
...                         #        or 5-8 (V, followed by 0 to 3 I&#39;s)
...     '$'                 # end of string
... )
>>> print pattern
'^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$'
</code></pre>
</summary>
<summary type="html"><p>Named formatting, % -formatting takes a dictionary (also applies %i/%s etc. validation).</p>

<pre class="prettyprint"><code>>>> print 'The %(foo)s is %(bar)i.' % {&#39;foo&#39;: &#39;answer&#39;, &#39;bar&#39;:42}
The answer is 42.

>>> foo, bar = &#39;question&#39;, 123

>>> print 'The %(foo)s is %(bar)i.' % locals()
The question is 123.
</code></pre>

<p>And since locals() is also a dictionary, you can simply pass that as a dict and have % -substitions from your local variables. I think this is frowned upon, but simplifies things..</p>

<p><strong>New Style Formatting</strong></p>

<pre class="prettyprint"><code>>>> print('The {foo} is {bar}'.format(foo=&#39;answer&#39;, bar=42))
</code></pre>
</summary>
<summary type="html"><p><strong>Creating new types in a fully dynamic manner</strong></p>

<pre class="prettyprint"><code>>>> NewType = type('NewType', (object,), {'x': 'hello'})
>>> n = NewType()
>>> n.x
'hello'
</code></pre>

<p>which is exactly the same as</p>

<pre class="prettyprint"><code>>>> class NewType(object):
>>>     x = 'hello'
>>> n = NewType()
>>> n.x
'hello'
</code></pre>

<p>Probably not the most useful thing, but nice to know.</p>

<p><strong>Edit</strong>: Fixed name of new type, should be <code>NewType</code> to be the exact same thing as with <code>class</code> statement.</p>

<p><strong>Edit</strong>: Adjusted the title to more accurately describe the feature.</p>
</summary>
<summary type="html"><p>To add more python modules (espcially 3rd party ones), most people seem to use PYTHONPATH environment variables or they add symlinks or directories in their site-packages directories. Another way, is to use *.pth files. Here&#39;s the official python doc&#39;s explanation:</p>

<blockquote>
<p>'The most convenient way [to modify
python&#39;s search path] is to add a path
configuration file to a directory
that&#39;s already on Python&#39;s path,
usually to the .../site-packages/
directory. Path configuration files
have an extension of .pth, and each
line must contain a single path that
will be appended to sys.path. (Because
the new paths are appended to
sys.path, modules in the added
directories will not override standard
modules. This means you can&#39;t use this
mechanism for installing fixed
versions of standard modules.)'</p>
</blockquote>
</summary>
<summary type="html"><p><strong>Built-in base64, zlib, and rot13 codecs</strong></p>

<p>Strings have <code>encode</code> and <code>decode</code> methods.  Usually this is used for converting <code>str</code> to <code>unicode</code> and vice versa, e.g. with <code>u = s.encode(&#39;utf8&#39;)</code>.  But there are some other handy builtin codecs.  Compression and decompression with zlib (and bz2) is available without an explicit import:</p>

<pre class="prettyprint"><code>>>> s = &#39;a&#39; * 100
>>> s.encode(&#39;zlib&#39;)
&#39;x\x9cKL\xa4=\x00\x00zG%\xe5&#39;
</code></pre>

<p>Similarly you can encode and decode base64:</p>

<pre class="prettyprint"><code>>>> &#39;Hello world&#39;.encode(&#39;base64&#39;)
&#39;SGVsbG8gd29ybGQ=\n&#39;
>>> &#39;SGVsbG8gd29ybGQ=\n&#39;.decode(&#39;base64&#39;)
&#39;Hello world&#39;
</code></pre>

<p>And, of course, you can rot13:</p>

<pre class="prettyprint"><code>>>> &#39;Secret message&#39;.encode(&#39;rot13&#39;)
&#39;Frperg zrffntr&#39;
</code></pre>
</summary>
<summary type="html"><p><b>Get the python regex parse tree to debug your regex</b></p>

<p>Regular expressions are a great feature of python, but debugging them can be a pain, and it&#39;s just too easy to get a regex wrong.</p>

<p>Fortunately, python have a really hidden feature to print the regex parse tree,
by passing the undocumented, experimental, hidden flag <code>re.DEBUG</code> (actually, 128) to <code>re.compile</code></p>

<pre class="prettyprint"><code>>>> re.compile('^\[font(?:=(?P&lt;size>[-+][0-9]{1,2}))?\](.*?)[/font]',
    re.DEBUG)
at at_beginning
literal 91
literal 102
literal 111
literal 110
literal 116
max_repeat 0 1
  subpattern None
    literal 61
    subpattern 1
      in
        literal 45
        literal 43
      max_repeat 1 2
        in
          range (48, 57)
literal 93
subpattern 2
  min_repeat 0 65535
    any None
in
  literal 47
  literal 102
  literal 111
  literal 110
  literal 116
</code></pre>

<p>Once you understand the syntax, you can spot your errors.
There we can see that I forgot to escape the <code>[]</code> in <code>[/font]</code>.</p>

<p>Of course you can combine it with whatever flags you want, like commented regexes :</p>

<pre class="prettyprint"><code>>>> re.compile('''
 ^              # start of a line
 \[font         # the font tag
 (?:=(?P&lt;size>  # optional [font=+size]
 [-+][0-9]{1,2} # size specification
 ))?
 \]             # end of tag
 (.*?)          # text between the tags
 \[/font\]      # end of the tag
 ''', re.DEBUG|re.VERBOSE|re.DOTALL)
</code></pre>
</summary>
<summary type="html"><p><a href='http://www.python.org/dev/peps/pep-0342/' rel='nofollow'>Sending values into generator functions</a>. For example having this function:</p>

<pre class="prettyprint"><code>def mygen():
    '''Yield 5 until something else is passed back via send()'''
    a = 5
    while True:
        f = (yield a) #yield a and possibly get f in return
        if f is not None: 
            a = f  #store the new value
</code></pre>

<p>You can:</p>

<pre class="prettyprint"><code>>>> g = mygen()
>>> g.next()
5
>>> g.next()
5
>>> g.send(7)  #we send this back to the generator
7
>>> g.next() #now it will yield 7 until we send something else
7
</code></pre>
</summary>
<summary type="html"><p><strong>Interactive Interpreter Tab Completion</strong></p>

<pre class="prettyprint"><code>try:
import readline
except ImportError:
print 'Unable to load readline module.'
else:
import rlcompleter
readline.parse_and_bind('tab: complete')


>>> class myclass:
...    def function(self):
...       print 'my function'
... 
>>> class_instance = myclass()
>>> class_instance.&lt;TAB>
class_instance.__class__   class_instance.__module__
class_instance.__doc__     class_instance.function
>>> class_instance.f&lt;TAB>unction()
</code></pre>

<p>You will also have to set a PYTHONSTARTUP environment variable.</p>
</summary>
<summary type="html"><p><strong>Ternary operator</strong></p>

<pre class="prettyprint"><code>>>> &#39;ham&#39; if True else &#39;spam&#39;
&#39;ham&#39;
>>> &#39;ham&#39; if False else &#39;spam&#39;
&#39;spam&#39;
</code></pre>

<p>This was added in 2.5, prior to that you could use:</p>

<pre class="prettyprint"><code>>>> True and &#39;ham&#39; or &#39;spam&#39;
&#39;ham&#39;
>>> False and &#39;ham&#39; or &#39;spam&#39;
&#39;spam&#39;
</code></pre>

<p>However, if the values you want to work with would be considered false, there is a difference:</p>

<pre class="prettyprint"><code>>>> [] if True else &#39;spam&#39;
[]
>>> True and [] or &#39;spam&#39;
&#39;spam&#39;
</code></pre>
</summary>
<summary type="html"><p>Exception <strong>else</strong> clause:</p>

<pre class="prettyprint"><code>try:
put_4000000000_volts_through_it(parrot)
except Voom:
print '&#39;E&#39;s pining!'
else:
print 'This parrot is no more!'
finally:
end_sketch()
</code></pre>

<p>The use of the else clause is better than adding additional code to the try clause because it avoids accidentally catching an exception that wasn’t raised by the code being protected by the try ... except statement.</p>

<p>See <a href='http://docs.python.org/tut/node10.html' rel='nofollow'>http://docs.python.org/tut/node10.html</a></p>
</summary>
<summary type="html"><p><strong>'Unpacking' to function parameters</strong></p>

<pre class="prettyprint"><code>def foo(a, b, c):
        print a, b, c

bar = (3, 14, 15)
foo(*bar)
</code></pre>

<p>When executed prints:</p>

<pre class="prettyprint"><code>3 14 15
</code></pre>
</summary>
<summary type="html"><p>Combine unpacking with the print function:</p>

<pre class="prettyprint"><code># in 2.6 &lt;= python &lt; 3.0, 3.0 + the print function is native
from __future__ import print_function 

mylist = [&#39;foo&#39;, &#39;bar&#39;, &#39;some other value&#39;, 1,2,3,4]  
print(*mylist)
</code></pre>
</summary>
<summary type="html"><p><strong>Context managers and the '<code>with</code>' Statement</strong></p>

<p>Introduced in <a href='http://www.python.org/dev/peps/pep-0343/' rel='nofollow'>PEP 343</a>, a <a href='http://docs.python.org/library/stdtypes.html#context-manager-types' rel='nofollow'>context manager</a> is an object that acts as a run-time context for a suite of statements.</p>

<p>Since the feature makes use of new keywords, it is introduced gradually: it is available in Python 2.5 via the <a href='http://docs.python.org/lib/module-future.html' rel='nofollow'><code>__future__</code></a> directive. Python 2.6 and above (including Python 3) has it available by default.</p>

<p>I have used the <a href='http://www.python.org/dev/peps/pep-0343/' rel='nofollow'>'with' statement</a> a lot because I think it&#39;s a very useful construct, here is a quick demo:</p>

<pre class="prettyprint"><code>from __future__ import with_statement

with open(&#39;foo.txt&#39;, &#39;w&#39;) as f:
f.write(&#39;hello!&#39;)
</code></pre>

<p>What&#39;s happening here behind the scenes, is that the <a href='http://www.python.org/dev/peps/pep-0343/' rel='nofollow'>'with' statement</a> calls the special <code>__enter__</code> and <code>__exit__</code> methods on the file object. Exception details are also passed to <code>__exit__</code> if any exception was raised from the with statement body, allowing for exception handling to happen there.</p>

<p>What this does for you in this particular case is that it guarantees that the file is closed when execution falls out of scope of the <code>with</code> suite, regardless if that occurs normally or whether an exception was thrown. It is basically a way of abstracting away common exception-handling code.</p>

<p>Other common use cases for this include locking with threads and database transactions. </p>
</summary>
</body>
