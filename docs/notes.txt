[30/3/12] Project review - checkpoint
-----------------------------------------------------------------------------
- regression testing + automatic crash finding + property testing

i. lazy instantiation technique
    to determine admissible types (including attributes - fields/methods - on objects) of each argument to function - objects are abstractly modelled as just dict(), essentially
    ie. complete range of test surface?
ii. now types are known, how to efficiently crawl this search space
    in order to generate the minimal representative subset test suite?
    - initially random
    - use feedback from dynamic execution to refine test cases generated/prune search space
    - gather insight from real life code libraries?
iii. testing recursive functions (& later, the other kinds of constructs)

- grand central dispatch parses list of bytecode into useful "breakpoint" nodes = mapped out all possible structures of the grammar - how can this be used?
- NO: unfortunately test data generation cannot be nested, eg. if within while loop, tests generated for it cannot be "added" iteratively into parent "while" test cases

- imagine function is a black box (with side effects), unit tests generated can only assert on return result values, and control type&value of input parameters, eg.
    def foo(a):     # a is unused parameter in method
        if False:
            while True:
                pass

- Impossible to ascertain correctness, instead fingerprint by mapping as representative inputs
- Assume well defined class under test

benchmarking code coverage: mutation testing...
How about mixing all types like class, recursion... into one file to benchmark?
also explore testing extensions - helper classes/methods - see numpy/scipy eg.

[29/3/12]
-----------------------------------------------------------------------------
- fuzzing / mutation testing
    ie. fingerprint module under test with test suite generated
    - modify source code of module under test & recompile
    - compare strictness of result with manually written tests

- Emulate stack
    - bytecode call graph with node
    - (id = hacked lineno, opcode, arg, # times node is visited, [outgoing children nodes])
- figure out arguments to function call

- testing recursive functions
    - generate tests asserting depth of recursion

@ http://w.icodesnip.com/search/python%20assignment%203/2

[28/3/12]
-----------------------------------------------------------------------------
Paper outline
    - Introduction & Overview
    - Definition of relevant concepts
    - Implementation
    - Sample applications
    - Conclusion

[22/3/12]
-----------------------------------------------------------------------------
What if the module under test has dependencies? Dynamically create it!
    http://bytes.com/topic/python/answers/433567-dynamically-add-class-modules
    http://www.saltycrane.com/blog/2010/09/class-based-fabric-scripts-metaprogramming-hack/
    http://stackoverflow.com/questions/301134/dynamic-module-import-in-python
    http://stackoverflow.com/questions/2931950/dynamic-module-creation
    http://technogeek.org/python-module.html
    http://code.activestate.com/recipes/82234-importing-a-dynamically-generated-module/
    http://www.b-list.org/weblog/2007/dec/03/making-magic/
    http://www.penzilla.net/tutorials/python/modules/
***
isinstance()
    - works on old-style classes
    - need to know type before calling
    - legit type-checking against a known class
__class__
    - works on old-style classes
    - no need to know type before calling
    - use for debugging: no idea what class the instance is
issubclass()
***
method_missing proxy
   @ http://langexplr.blogspot.com/2008/02/handling-call-to-missing-method-in_06.html
   @ http://orestis.gr/blog/2007/12/10/python_getattr/

tracing & profiling
   @ http://www.doughellmann.com/PyMOTW/sys/tracing.html

Python source code
   @ http://svn.python.org/view/python/trunk/Python/compile.c?view=markup

co_lnotab
   @ http://svn.python.org/projects/python/trunk/Objects/lnotab_notes.txt

hacking Python bytecode tracing
   @ http://nedbatchelder.com/blog/200804/wicked_hack_python_bytecode_tracing.html

str vs repr
    %s specifier converts the object using str();
    %r converts it using repr()
>>> str(datetime.date.today())  '2011-05-14'
>>> repr(d)                     'datetime.date(2011, 5, 14)'
***
code coverage analysis:
    - fingerprint benchmark modules
        - sloccount
        - coverage / tox
        - mutation eg. (p)ester
    - metric = LCSAJ
- reloading modules
TODO:
    - Loops         m4,11,18
    - Conditionals  fizzbuzz
    - Recursion     fac, fib, hanoi, binsearch, gcd, merge/quicksort
        - assume base + recursive case
    - Generators
    - Containers
    - Objects
Ideas
    - context stack
    - hunt for critical boundary values in bytecode to test, esp. numerics
    - benchmarks:
        - dexml, num/scipy, quixeychallenge
        - compare with shipped tests, in terms of:
            - coverage
            - accuracy of fingerprinting test module

eval vs. exec vs. compile @ http://goo.gl/gY5Pb
1. exec
    - statement, not expression (function in Py3k)
    - compiles & immediately evaluates statements in a string
    eg. exec 'if True: print 5\nprint 6; 5'

2. eval
    - evaluates an expression (NOT STATEMENT)
    - and returns value expression produces
    eg. eval('abs(%d)' % -100)

3. compile(string, '', <mode>)
    - lower level version of exec+eval
    - does not execute or evaluate statements or expressions
    - but returns a code object that can do it
    <mode>
        a. 'eval' - equivalent code object to 'eval(string)'; no statements, only single expression
        b. 'exec' - equivalent code object to 'exec(string)'; statements+ allowed
        c. 'single' - ignore everything except first statement (if/else considered one)

[13/3/12]
-----------------------------------------------------------------------------
Compare both strings & int/float
    [...
        (LOAD_FAST, 'one'),
        (LOAD_FAST, 2),
        (COMPARE_OP, '==')
    ...]
- mutate assignments, branches in module under test, and run against generated test suite,
the larger percentage of test failures, the better quality of the generated test suite
- assume Python code not compiled optimised (where asserts are removed in bytecode)
- excludes Python C extension modules

CALL_FUNCTION(argc)Â¶
Calls a function. The low byte of argc indicates the number of positional parameters, the high byte the number of keyword parameters. On the stack, the opcode finds the keyword parameters first. For each keyword argument, the value is on top of the key. Below the keyword parameters, the positional parameters are on the stack, with the right-most parameter on top. Below the parameters, the function object to call is on the stack. Pops all function arguments, and the function itself off the stack, and pushes the return value.

@ http://docs.python.org/dev/reference/executionmodel.html
"block" A piece of Python program text that is executed as a unit. The following are blocks: a module, a function body and a class definition.

=============================================================================
[7/3/12] callable() vs. hasattr(obj, "__call__")
-----------------------------------------------------------------------------
If you use the python builtin "callable" instead of "hasattr(type_func, 
'__call__')", then classes can be used as argument types, ie.
class A:
    pass
callable(A) = True
hasattr(A, "__call__") = False

Example:
>>> class P(property):
...   def __get__(self, obj, cls):
...     1/0
>>> class C(object):
...   __call__ = P()
>>> c = C()
>>> callable(c)
True
>>> hasattr(c, "__call__")
False
>>> c.__call__
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in __get__
ZeroDivisionError: integer division or modulo by zero

The reason is that hasattr() really calls getattr() and then discards the result / catches any exception, while callable() only examines the type's structure (callable() is lower level).

built-in function is easier to read, better performance than attribute lookup, ie.
$ python -m timeit "hasattr(None, '__call__')"
1000000 loops, best of 3: 1.22 usec per loop
$ ./python -m timeit "callable(None)"
10000000 loops, best of 3: 0.176 usec per loop

$ python -m timeit "hasattr(str, '__call__')"
1000000 loops, best of 3: 0.326 usec per loop
$ python -m timeit "callable(str)"
1000000 loops, best of 3: 0.195 usec per loop
_____________________________________________________________________________
