\BOOKMARK [0][-]{chapter.1}{1 Introduction}{}% 1
\BOOKMARK [1][-]{section.1.1}{1.1 Motivation}{chapter.1}% 2
\BOOKMARK [1][-]{section.1.2}{1.2 Automated software testing for dynamic languages}{chapter.1}% 3
\BOOKMARK [1][-]{section.1.3}{1.3 The Python programming language}{chapter.1}% 4
\BOOKMARK [1][-]{section.1.4}{1.4 Project contributions}{chapter.1}% 5
\BOOKMARK [1][-]{section.1.5}{1.5 Report organisation}{chapter.1}% 6
\BOOKMARK [0][-]{chapter.2}{2 Background}{}% 7
\BOOKMARK [1][-]{section.2.1}{2.1 Introduction}{chapter.2}% 8
\BOOKMARK [1][-]{section.2.2}{2.2 Definition of terms}{chapter.2}% 9
\BOOKMARK [2][-]{subsection.2.2.1}{2.2.1 General software testing}{section.2.2}% 10
\BOOKMARK [2][-]{subsection.2.2.2}{2.2.2 Modelling programs as graphs}{section.2.2}% 11
\BOOKMARK [1][-]{section.2.3}{2.3 Overview}{chapter.2}% 12
\BOOKMARK [2][-]{subsection.2.3.1}{2.3.1 Functional testing}{section.2.3}% 13
\BOOKMARK [2][-]{subsection.2.3.2}{2.3.2 Structural testing}{section.2.3}% 14
\BOOKMARK [3][-]{subsubsection.2.3.2.1}{2.3.2.1 Static approach}{subsection.2.3.2}% 15
\BOOKMARK [3][-]{subsubsection.2.3.2.2}{2.3.2.2 Dynamic approach}{subsection.2.3.2}% 16
\BOOKMARK [2][-]{subsection.2.3.3}{2.3.3 Hybrid testing}{section.2.3}% 17
\BOOKMARK [2][-]{subsection.2.3.4}{2.3.4 Testability transformation}{section.2.3}% 18
\BOOKMARK [1][-]{section.2.4}{2.4 Existing tools}{chapter.2}% 19
\BOOKMARK [2][-]{subsection.2.4.1}{2.4.1 RuTeG}{section.2.4}% 20
\BOOKMARK [2][-]{subsection.2.4.2}{2.4.2 Python}{section.2.4}% 21
\BOOKMARK [3][-]{subsubsection.2.4.2.1}{2.4.2.1 FizzBuzz \(sample Python module\)}{subsection.2.4.2}% 22
\BOOKMARK [3][-]{subsubsection.2.4.2.2}{2.4.2.2 Pythoscope}{subsection.2.4.2}% 23
\BOOKMARK [3][-]{subsubsection.2.4.2.3}{2.4.2.3 Pytestsgenerator}{subsection.2.4.2}% 24
\BOOKMARK [1][-]{section.2.5}{2.5 The Python programming language}{chapter.2}% 25
\BOOKMARK [2][-]{subsection.2.5.1}{2.5.1 Dynamic typing}{section.2.5}% 26
\BOOKMARK [2][-]{subsection.2.5.2}{2.5.2 Introspection/reflection}{section.2.5}% 27
\BOOKMARK [2][-]{subsection.2.5.3}{2.5.3 Runtime modification}{section.2.5}% 28
\BOOKMARK [2][-]{subsection.2.5.4}{2.5.4 Data model}{section.2.5}% 29
\BOOKMARK [3][-]{subsubsection.2.5.4.1}{2.5.4.1 Objects}{subsection.2.5.4}% 30
\BOOKMARK [3][-]{subsubsection.2.5.4.2}{2.5.4.2 Type objects}{subsection.2.5.4}% 31
\BOOKMARK [3][-]{subsubsection.2.5.4.3}{2.5.4.3 Containers}{subsection.2.5.4}% 32
\BOOKMARK [3][-]{subsubsection.2.5.4.4}{2.5.4.4 Bytecode}{subsection.2.5.4}% 33
\BOOKMARK [1][-]{section.2.6}{2.6 Challenges}{chapter.2}% 34
\BOOKMARK [2][-]{subsection.2.6.1}{2.6.1 Function argument instantiation}{section.2.6}% 35
\BOOKMARK [3][-]{subsubsection.2.6.1.1}{2.6.1.1 Lazy instantiation}{subsection.2.6.1}% 36
\BOOKMARK [3][-]{subsubsection.2.6.1.2}{2.6.1.2 Runtime in-memory manipulation}{subsection.2.6.1}% 37
\BOOKMARK [3][-]{subsubsection.2.6.1.3}{2.6.1.3 Random testing}{subsection.2.6.1}% 38
\BOOKMARK [2][-]{subsection.2.6.2}{2.6.2 Optimising search space coverage}{section.2.6}% 39
\BOOKMARK [2][-]{subsection.2.6.3}{2.6.3 Testing a dynamically typed language}{section.2.6}% 40
\BOOKMARK [2][-]{subsection.2.6.4}{2.6.4 Non-terminating program executions}{section.2.6}% 41
\BOOKMARK [2][-]{subsection.2.6.5}{2.6.5 Early detection of path infeasibility}{section.2.6}% 42
\BOOKMARK [2][-]{subsection.2.6.6}{2.6.6 Improving code coverage}{section.2.6}% 43
\BOOKMARK [1][-]{section.2.7}{2.7 Summary}{chapter.2}% 44
\BOOKMARK [0][-]{chapter.3}{3 Contributions}{}% 45
\BOOKMARK [1][-]{section.3.1}{3.1 Key characteristics}{chapter.3}% 46
\BOOKMARK [1][-]{section.3.2}{3.2 Limitations}{chapter.3}% 47
\BOOKMARK [1][-]{section.3.3}{3.3 Approach}{chapter.3}% 48
\BOOKMARK [2][-]{subsection.3.3.1}{3.3.1 Testing recursive functions}{section.3.3}% 49
\BOOKMARK [1][-]{section.3.4}{3.4 Challenges}{chapter.3}% 50
\BOOKMARK [2][-]{subsection.3.4.1}{3.4.1 Python modules with own imports}{section.3.4}% 51
\BOOKMARK [2][-]{subsection.3.4.2}{3.4.2 Lack of existing tool support}{section.3.4}% 52
\BOOKMARK [2][-]{subsection.3.4.3}{3.4.3 Vague error messages}{section.3.4}% 53
\BOOKMARK [2][-]{subsection.3.4.4}{3.4.4 Relationship between input arguments}{section.3.4}% 54
\BOOKMARK [2][-]{subsection.3.4.5}{3.4.5 Various kinds of programs}{section.3.4}% 55
\BOOKMARK [2][-]{subsection.3.4.6}{3.4.6 Range of values for testing}{section.3.4}% 56
\BOOKMARK [1][-]{section.3.5}{3.5 Available tools}{chapter.3}% 57
\BOOKMARK [2][-]{subsection.3.5.1}{3.5.1 Parsers}{section.3.5}% 58
\BOOKMARK [2][-]{subsection.3.5.2}{3.5.2 Unit test frameworks}{section.3.5}% 59
\BOOKMARK [2][-]{subsection.3.5.3}{3.5.3 Graphical User Interface \(GUI\) toolkits}{section.3.5}% 60
\BOOKMARK [2][-]{subsection.3.5.4}{3.5.4 Code coverage}{section.3.5}% 61
\BOOKMARK [2][-]{subsection.3.5.5}{3.5.5 Alternative implementations}{section.3.5}% 62
\BOOKMARK [2][-]{subsection.3.5.6}{3.5.6 Supporting utilities}{section.3.5}% 63
\BOOKMARK [1][-]{section.3.6}{3.6 Design decisions}{chapter.3}% 64
\BOOKMARK [2][-]{subsection.3.6.1}{3.6.1 callable\(\) vs. hasattr\(obj, "\137\137call\137\137"\)}{section.3.6}% 65
\BOOKMARK [1][-]{section.3.7}{3.7 Algorithm}{chapter.3}% 66
\BOOKMARK [2][-]{subsection.3.7.1}{3.7.1 Example}{section.3.7}% 67
\BOOKMARK [1][-]{section.3.8}{3.8 Summary}{chapter.3}% 68
\BOOKMARK [0][-]{chapter.4}{4 Splat}{}% 69
\BOOKMARK [1][-]{section.4.1}{4.1 Architecture}{chapter.4}% 70
\BOOKMARK [1][-]{section.4.2}{4.2 Components}{chapter.4}% 71
\BOOKMARK [2][-]{subsection.4.2.1}{4.2.1 Main run scripts}{section.4.2}% 72
\BOOKMARK [2][-]{subsection.4.2.2}{4.2.2 Validator}{section.4.2}% 73
\BOOKMARK [2][-]{subsection.4.2.3}{4.2.3 Bytecode scanner \046 Instrumentor}{section.4.2}% 74
\BOOKMARK [2][-]{subsection.4.2.4}{4.2.4 Program analyser}{section.4.2}% 75
\BOOKMARK [2][-]{subsection.4.2.5}{4.2.5 Unit test generator}{section.4.2}% 76
\BOOKMARK [3][-]{subsubsection.4.2.5.1}{4.2.5.1 all [style=mypythoninline]Nones}{subsection.4.2.5}% 77
\BOOKMARK [3][-]{subsubsection.4.2.5.2}{4.2.5.2 all [style=mypythoninline]Nones, with structure}{subsection.4.2.5}% 78
\BOOKMARK [3][-]{subsubsection.4.2.5.3}{4.2.5.3 [style=mypythoninline]MetaParams, with structure and defaults}{subsection.4.2.5}% 79
\BOOKMARK [3][-]{subsubsection.4.2.5.4}{4.2.5.4 Lazy instantiation}{subsection.4.2.5}% 80
\BOOKMARK [3][-]{subsubsection.4.2.5.5}{4.2.5.5 Argument list to UnitTestObject}{subsection.4.2.5}% 81
\BOOKMARK [3][-]{subsubsection.4.2.5.6}{4.2.5.6 Recursive function tester}{subsection.4.2.5}% 82
\BOOKMARK [2][-]{subsection.4.2.6}{4.2.6 Template writer}{section.4.2}% 83
\BOOKMARK [2][-]{subsection.4.2.7}{4.2.7 Auxiliary tools}{section.4.2}% 84
\BOOKMARK [1][-]{section.4.3}{4.3 Summary}{chapter.4}% 85
\BOOKMARK [0][-]{chapter.5}{5 Evaluation}{}% 86
\BOOKMARK [1][-]{section.5.1}{5.1 Experiment}{chapter.5}% 87
\BOOKMARK [1][-]{section.5.2}{5.2 Evaluation criteria}{chapter.5}% 88
\BOOKMARK [2][-]{subsection.5.2.1}{5.2.1 Code coverage}{section.5.2}% 89
\BOOKMARK [3][-]{subsubsection.5.2.1.1}{5.2.1.1 Basic coverage criteria}{subsection.5.2.1}% 90
\BOOKMARK [3][-]{subsubsection.5.2.1.2}{5.2.1.2 Additional coverage criteria}{subsection.5.2.1}% 91
\BOOKMARK [2][-]{subsection.5.2.2}{5.2.2 Performance}{section.5.2}% 92
\BOOKMARK [2][-]{subsection.5.2.3}{5.2.3 Quality of test data}{section.5.2}% 93
\BOOKMARK [3][-]{subsubsection.5.2.3.1}{5.2.3.1 Mutation testing}{subsection.5.2.3}% 94
\BOOKMARK [2][-]{subsection.5.2.4}{5.2.4 Generality}{section.5.2}% 95
\BOOKMARK [1][-]{section.5.3}{5.3 Selection of programs}{chapter.5}% 96
\BOOKMARK [2][-]{subsection.5.3.1}{5.3.1 Fingerprinting Python modules}{section.5.3}% 97
\BOOKMARK [2][-]{subsection.5.3.2}{5.3.2 Coverage results}{section.5.3}% 98
\BOOKMARK [2][-]{subsection.5.3.3}{5.3.3 Discussion}{section.5.3}% 99
\BOOKMARK [1][-]{section.5.4}{5.4 Summary}{chapter.5}% 100
\BOOKMARK [0][-]{chapter.6}{6 Conclusion \046 Future Work}{}% 101
\BOOKMARK [0][-]{chapter*.11}{Bibliography}{}% 102
\BOOKMARK [0][-]{appendix.A}{A Python 2.7 Grammar \(EBNF\)}{}% 103
\BOOKMARK [0][-]{appendix.B}{B Type hierarchy}{}% 104
\BOOKMARK [0][-]{appendix.C}{C Exception hierarchy}{}% 105
\BOOKMARK [0][-]{appendix.D}{D Python objects}{}% 106
\BOOKMARK [1][-]{section.D.1}{D.1 frame object}{appendix.D}% 107
\BOOKMARK [1][-]{section.D.2}{D.2 code object}{appendix.D}% 108
\BOOKMARK [0][-]{appendix.E}{E Python 2.7 opcodes}{}% 109
\BOOKMARK [0][-]{appendix.F}{F Source code to Bytecode mapping}{}% 110
