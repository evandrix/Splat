[22/3/12]
-----------------------------------------------------------------------------
code coverage analysis:
    - fingerprint benchmarks modules
        - sloccount
        - coverage / tox
        - mutation eg. (p)ester
    - metric = LCSAJ
- reloading modules
TODO:
    - Loops         m4,11,18
    - Conditionals  fizzbuzz
    - Recursion     fac, fib, hanoi, binsearch, gcd, merge/quicksort
        - assume base + recursive case
    - Generators
    - Containers
    - Objects
Ideas
    - context stack
    - hunt for critical boundary values in bytecode to test, esp. numerics
    - benchmarks:
        - dexml, num/scipy, quixeychallenge
        - compare with shipped tests, in terms of:
            - coverage
            - accuracy of fingerprinting test module

eval vs. exec vs. compile
@ http://goo.gl/gY5Pb
1. exec
    - statement, not expression (function in Py3k)
    - compiles & immediately evaluates statements in a string
    eg. exec 'if True: print 5\nprint 6; 5'

2. eval
    - evaluates an expression (NOT STATEMENT)
    - and returns value expression produces
    eg. eval('abs(%d)' % -100)

3. compile(string, '', <mode>)
    - lower level version of exec+eval
    - does not execute or evaluate statements or expressions
    - but returns a code object that can do it
    <mode>
        a. 'eval' - equivalent code object to 'eval(string)'; no statements, only single expression
        b. 'exec' - equivalent code object to 'exec(string)'; statements+ allowed
        c. 'single' - ignore everything except first statement (if/else considered one)

[13/3/12]
-----------------------------------------------------------------------------
Compare both strings & int/float
    [...
        (LOAD_FAST, 'one'),
        (LOAD_FAST, 2),
        (COMPARE_OP, '==')
    ...]
- mutate assignments, branches in module under test, and run against generated test suite,
the larger percentage of test failures, the better quality of the generated test suite
- assume Python code not compiled optimised (where asserts are removed in bytecode)
- excludes Python C extension modules

CALL_FUNCTION(argc)Â¶
Calls a function. The low byte of argc indicates the number of positional parameters, the high byte the number of keyword parameters. On the stack, the opcode finds the keyword parameters first. For each keyword argument, the value is on top of the key. Below the keyword parameters, the positional parameters are on the stack, with the right-most parameter on top. Below the parameters, the function object to call is on the stack. Pops all function arguments, and the function itself off the stack, and pushes the return value.

@ http://docs.python.org/dev/reference/executionmodel.html
"block" A piece of Python program text that is executed as a unit. The following are blocks: a module, a function body and a class definition.

=============================================================================
[7/3/12] callable() vs. hasattr(obj, "__call__")
-----------------------------------------------------------------------------
If you use the python builtin "callable" instead of "hasattr(type_func, 
'__call__')", then classes can be used as argument types, ie.
class A:
    pass
callable(A) = True
hasattr(A, "__call__") = False

Example:
>>> class P(property):
...   def __get__(self, obj, cls):
...     1/0
>>> class C(object):
...   __call__ = P()
>>> c = C()
>>> callable(c)
True
>>> hasattr(c, "__call__")
False
>>> c.__call__
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in __get__
ZeroDivisionError: integer division or modulo by zero

The reason is that hasattr() really calls getattr() and then discards the result / catches any exception, while callable() only examines the type's structure (callable() is lower level).

built-in function is easier to read, better performance than attribute lookup, ie.
$ python -m timeit "hasattr(None, '__call__')"
1000000 loops, best of 3: 1.22 usec per loop
$ ./python -m timeit "callable(None)"
10000000 loops, best of 3: 0.176 usec per loop

$ python -m timeit "hasattr(str, '__call__')"
1000000 loops, best of 3: 0.326 usec per loop
$ python -m timeit "callable(str)"
1000000 loops, best of 3: 0.195 usec per loop
_____________________________________________________________________________
