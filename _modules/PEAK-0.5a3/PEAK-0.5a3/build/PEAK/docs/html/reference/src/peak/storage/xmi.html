<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
          "http://www.w3.org/TR/html40/loose.dtd">

<html>
         
  <head>
    <title>Module: xmi</title>
  </head>

  <body bgcolor="#ffffff">

        <p><i><a href="../../../index.html">Table of Contents</a></i></p>
        
        <table border="0" cellpadding="5" cellspacing="0" width="100%">
        <tr>
            <th rowspan="2"
                valign="top"
                align="left"
                width="10%"
                bgcolor="#88bbee"><font color="#000000">Module: xmi</font>
            </th>
            <th bgcolor="#88bbee"
                width="90%"
                align="right"><font color="#000000">./src/peak/storage/xmi.py</font>
            </th>
        </tr>
        <tr>
        <td>
        
<h3>Base classes for storing/retrieving model objects via XMI format</h3>
<p>    Because the XMI 1.x specs are incredibly confusing and self-contradictory,
    it's necessary for us to clarify our interpretations of the specs and
    what restrictions we are placing upon our implementation goals.</p>
<h4>    Our intended uses of XMI are as follows:</h4>

<ol>
<li><p> Processing of UML models saved by commonly-available design tools</p></li>
<li><p> Code generation from MOF metamodels for modelling languages such as
        UML and CWM, which are supplied in XMI format by the OMG and other
        standards bodies.</p></li>
<li><p> Use as a metadata-driven persistence and import/export format for
        PEAK applications.  (The idea being that a readable format that
        doesn't require custom coding would make it easy to experiment
        with domain model designs, and to create test suites and test
        data for domain logic verification before the &quot;final&quot; storage
        machinery is built.)</p></li>

</ol>
<p>    Usage 1 only requires reading of XMI 1.0 and 1.1 features needed by
    UML models, and is effectively complete now.  Usage 2 requires support
    for reading <code>XMI.any</code> and CORBA typecodes.  Usage 3 requires that we
    be able to write XMI files - and any version would suffice.  However,
    if we support both 1.0 and 1.1 format for writing XMI, then we could
    support doing automated transforms of UML content, generation of UML
    or other constructs from code or database schemas, etc.  So ideally,
    we should be able to write both 1.0 and 1.1.</p>
<p>    XMI 2.0 looks very promising from the perspective of future tool
    support, but unfortunately it will not help us with any usage but #3.
    It may also need a somewhat differently structured implementation.  So
    for now we will mostly ignore XMI 2.0.  However, 2.0 introduces the idea
    of using tagged values on a metamodel to specify implementation
    details such as variations in tag or attribute names, etc., that would
    be useful to have for our intended applications.  So, where applicable,
    we will represent these tagged values as PEAK configuration properties
    of the form <code>org.omg.xmi.*</code> corresponding to the official XMI tag
    names for those configuration options.</p>
<p>    Within the XMI 1.x series, we will not support the <code>XMI.TypeDefinitions</code>
    block and its contents.  Survey of existing XMI files suggests this is
    not used in practice, and it was removed as of the XMI 1.2 spec.
    Unfortunately, we <em>do</em> have to support the <code>XMI.Corba*</code> tags, as they
    are used by metamodels (such as UML and CWM) that are defined based on
    MOF 1.3 or earlier.  (MOF 1.4 and up abandon Corba typecodes as a basis
    for metamodel definition; unfortunately, few systems of interest to us
    are presently based on the MOF 1.4 metametamodel.)</p>
<p>    In any case, the <code>XMI.TypeDefinitions</code> block is only used when encoding
    datatypes that are not part of the metamodel for the data being encoded.
    For PEAK applications, all such type definitions should be part of the
    model, and this is true for common UML usage as well.</p>
<h4>    TODO</h4>
<h5>        Write Algorithm</h5>

<ul>
<li><p>needs to know composition link direction (needs peak.model support)</p></li>
<li><p>Element state will contain a reference to pseudo-DOM node, if
            available.  Elements are saved by modifying node in-place.
            Sub-elements are saved using their node, if the node's parent is
            the containing element's node.  If the sub-element has no node,
            save the sub-element (creating a node), and point its node's
            parent to the current element's node.</p></li>
<li><p>If the sub-element's node's parent is <em>not</em> the current element's
            node, create an <code>xmi.idref</code> node linking to the sub-element node.</p></li>
<li><p>New elements, and non-persistent objects simply create a &quot;fresh&quot;
            node for use by the containing element.  Elements keep a reference
            to this new node, so that potential containers can tell if they've
            seen it.</p></li>
<li><p>We only care about keeping XMI.Extension tags contained directly
            in an element, in the top-level object list (XMI.content), and
            in the XMI.Extensions block.  If a node is modified, its extension
            tags may be moved to the end of the modified node's children.</p></li>
<li><p>Generate new ID's as UUIDs, and place in both UUID and ID fields;
            need to standardize on a <code>__uuid__</code> or similar field in elements
            so that elements that need/want a UUID to map over to/from another
            data system can do so.</p></li>
<li><p>Format transforms can be supported via DM.thunk(); it should be
            possible to copy an entire model from one DM to another in this
            way, and thus switch between XMI 1.0 and 1.1 (or other) storage
            formats.</p></li>
<li><p>For thunking to be effective, XMI.extensions must be sharable,
            and therefore immutable -- so we need an XMI extension/text class.</p></li>
<li><p>XMIDocument should become persistent, and use a second-order DM to
            load/save it.  Modifying XMINode instances should flag the
            XMIDocument as changed.  We can then implement a transactional
            file-based DM that can load and save the XMIDocument itself.</p></li>
<li><p>XMIDocument needs to know its version or select a strategy object
            to handle node updates for a particular XMI version.</p></li>
<li><p>Need to research <code>ignorableWhitespace</code> et al to ensure that we can
            write cleanly indented files but with same semantics as originals.</p></li>

</ul>
<h5>        XMI 1.2</h5>
<h6>            XMI 1.2 is mostly a simplification and clarification of XMI 1.1:</h6>

<ul>
<li><p>Encoding of multi-valued attributes; note that it is not
                  permissible to have a value for a feature both in an
                  object tag's attribute and in the object's contained tags.</p></li>
<li><p>&quot;Nested packages may result in name collision; a namespace
                  prefix is required in this case.&quot;  Need to review EBNF,
                  and &quot;Namespace Qualified XML Element Names&quot;.  This may
                  require metadata support on the writing side.</p></li>

</ul>
<h5>        XMI 2.0</h5>

<ul>
<li><p>Requires full URI-based namespace handling; maybe we should
              go ahead and add this to current implementation?  Note that
              this means all the <code>xmi.*</code> tag and attribute names are now
              <code>xmi:</code> instead.</p></li>
<li><p>Further note on namespace handling: it sounds as though
              XML attribute names for the target model are unqualified, and
              indeed that element names can be so as well.</p></li>
<li><p>Top-level element may not be the <code>XMI</code> tag; if a document
              represents a single object and doesn't want to include the
              XMI documentation, it can simply add an <code>xmi:version</code>
              attribute to the outermost tag representing the serialized
              object.</p></li>
<li><p>Compositions are less regular: instead of nesting object
              tags inside an attribute tag, the attribute and object tags
              can be combined.  The tag name is the attribute name, and a
              new <code>xmi:type</code> attribute indicates the type of the object.
              If omitted, the type of the object is assumed to be the type
              specified by the composite reference.</p></li>
<li><p>Although <code>xmi:id</code> is the normal ID attribute, it can be
              specified via a tagged value as being different.  It isn't
              clear how this would work if there were multiple ID attributes
              per XMI file.</p></li>

</ul>
<h5>        Other</h5>

<ul>
<li><p>metamodel lookups</p></li>
<li><p>cross-reference between files could be supported by having document
            objects able to supply a relative or absolute reference to another
            document.  But this requires HREF support.  :(  Note that
            cross-file HREF needs some way to cache the other documents and an
            associated DM, if it's to be dynamic.</p></li>

</ul>
<table border="0" cellpadding="5" cellspacing="0" width="100%">

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="Imported modules">Imported modules</a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        
<b>from</b> kjbuckets <b>import</b> kjGraph<br>
<b>from</b> peak.api <b>import</b> *<br>
<b>from</b> peak.model.api <b>import</b> TCKind, SimpleTC, Boolean, TypeCode<br>
<b>from</b> peak.persistence <b>import</b> Persistent<br>
<b>from</b> peak.util <b>import</b> SOX<br>
<b>from</b> <a href="http://www.python.org/doc/current/lib/module-types.html">types</a> <b>import</b> StringTypes<br>
<b>from</b> <a href="http://www.python.org/doc/current/lib/module-weakref.html">weakref</a> <b>import</b> WeakValueDictionary<br>
<b>from</b> xml.sax <b>import</b> saxutils<br>

</td></tr>

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="Functions">Functions</a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        
<a href="#fromFile">fromFile</a><br>


        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="fromFile"></a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">fromFile&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        <font color="#000088"><pre>
fromFile (
        filename_or_stream,
        parentComponent,
        **kw,
        )

</pre></font>

</td></tr>

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="Classes">Classes</a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        
<table border="0" cellpadding="3" cellspacing="0">
<tr><td valign="top" align="left"><p><a href="xmi/DM.html">DM</a></p></td><td valign="top" align="left"></td></tr>
<tr><td valign="top" align="left"><p><a href="xmi/XMIDocument.html">XMIDocument</a></p></td><td valign="top" align="left"></td></tr>
<tr><td valign="top" align="left"><p><a href="xmi/XMINode.html">XMINode</a></p></td><td valign="top" align="left"></td></tr>
</table>
</td></tr>
</td></tr>
</table>

        </td>
        </tr>
        </table>

        <hr>

        <p><i><a href="../../../index.html">Table of Contents</a></i></p>

        <font size="-2"><i>This document was automatically generated
        on Tue Feb 17 19:55:50 2004 by
        <a href="http://happydoc.sourceforge.net">HappyDoc</a> version
        2.1</i></font>
        
        </body>
        </html>
        