<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
          "http://www.w3.org/TR/html40/loose.dtd">

<html>
         
  <head>
    <title>Module: modules</title>
  </head>

  <body bgcolor="#ffffff">

        <p><i><a href="../../../index.html">Table of Contents</a></i></p>
        
        <table border="0" cellpadding="5" cellspacing="0" width="100%">
        <tr>
            <th rowspan="2"
                valign="top"
                align="left"
                width="10%"
                bgcolor="#88bbee"><font color="#000000">Module: modules</font>
            </th>
            <th bgcolor="#88bbee"
                width="90%"
                align="right"><font color="#000000">./src/peak/config/modules.py</font>
            </th>
        </tr>
        <tr>
        <td>
        
<h3>Module Inheritance and Patching</h3>
<p>    The APIs defined here let you create modules which derive from other
    modules, by defining a module-level <code>__bases__</code> attribute which lists
    the modules you wish to inherit from.  For example:
<pre>
        from peak.api import *

        import BaseModule1, BaseModule2

        __bases__ = BaseModule1, BaseModule2

        class MyClass:
            ...

        binding.setupModule()
</pre>
</p>
<p>    The <code>setupModule()</code> call will convert the calling module, <code>BaseModule1</code>,
    and <code>BaseModule2</code> into specially altered bytecode objects and execute
    them (in &quot;method-resolution order&quot;) rewriting the calling module's
    dictionary in the process.  The result is rather like normal class
    inheritance, except that classes (even nested classes) are merged by name,
    and metaclass constraints are inherited.  So an inheriting module need
    not list all the classes from its base module in order to change them
    by altering a base class in that module.</p>
<p>    Note: All the modules listed in <code>__bases__</code> must either call
    <code>setupModule()</code> themselves, or be located in an on-disk <code>.py</code>, <code>.pyc</code>, or
    <code>.pyo</code> file.  This is because PEAK cannot otherwise get access to
    their bytecode in a way that is compatible with the many &quot;import hook&quot;
    systems that exist for Python.  (E.g. running bytecode from zip files or
    frozen into an executable, etc.)  So if you are using such a code
    distribution technique, you must ensure that the base modules call
    <code>setupModule()</code>, even if they do not have a <code>__bases__</code> setting or use
    any other PEAK code.</p>
<h4>    Function Rebinding</h4>
<p>        All functions inherited via &quot;module inheritance&quot; using <code>setupModule()</code>
        (including those which are instance or class methods) have their
        globals rebound to point to the inheriting module.  This means that if
        a function or method references a global in the base module you're
        inheriting from, you can override that global in the inheriting module,
        without having to recode the function that referenced it.  (This is
        especially useful for <code>super()</code> calls, which usually use global
        references to class names!)</p>
<p>        In addition to rebinding general globals, functions which reference
        the global name <code>__proceed__</code> are also specially rebound so that
        <code>__proceed__</code> is the previous definition of that function, if any, in
        the inheritance list.  (It is <code>None</code> if there is no previous
        definition.)  This allows you to do the rough equivalent of a <code>super()</code>
        call (or AspectJ &quot;around advice&quot;) without having to explicitly import
        the old version of a function.  Note that <code>__proceed__</code> is always
        either a function or <code>None</code>, so you must include <code>self</code> as a parameter
        when calling it from a method definition.</p>
<h4>    Pickling Instances of Nested Classes and the <code>__name__</code> Attribute</h4>
<p>        One more bonus of using <code>setupModule()</code> is that instances of nested
        classes defined in modules using <code>setupModule()</code> will be pickleable.
        Ordinarily, nested class instances aren't pickleable because Python
        doesn't know how to find them, using only <code>someClass.__name__</code> and
        <code>someClass.__module__</code>.</p>
<p>        PEAK overcomes this problem by renaming nested classes so that
        they are defined with their full dotted name (e.g. <code>Foo.Bar</code> for
        class <code>Bar</code> nested in class <code>Foo</code>), and saving a reference to the class
        under its dotted name in the module dictionary.  This means that
        <code>someClass.__name__</code> may not be what you'd normally expect, and that
        doing <code>del someClass</code> may not delete all references to a class.  But
        pickling and unpickling should work normally.</p>
<p>        Note that some PEAK classes and metaclasses provide a &quot;short
        form&quot; of the class name for use when appropriate.  For example,
        Feature classes have an <code>attrName</code> class attribute.  In a pinch, you
        can also use <code>__name__.split(".")[-1]</code> to get the undotted form of
        a class' name.</p>
<h4>    Special Considerations for Mutables and Dynamic Initialization</h4>
<p>        Both inheritance and patching are implemented by running hacked,
        module-level code under a &quot;simulator&quot; that intercepts the setting of
        variables.  This works great for static definitions like <code>class</code>
        and <code>def</code> statements, constant assignments, <code>import</code>, etc.  It also
        works reasonably well for many other kinds of static initialization
        of immutable objects</p>
<p>        Mutable values, however, may require special considerations.  For
        example, if a module sets up some kind of registry as a module-level
        variable, and an inheriting module overrides the definition, things
        can get tricky.  If the base module writes values into that registry as
        part of module initialization, those values will also be written into
        the registry defined by the derived module.</p>
<p>        Another possible issue is if the base module performs other externally
        visible, non-idempotent operations, such as registering classes or
        functions in another module's registry, printing things to the console,
        etc.  The simple workaround for all these considerations, however, is
        to move your dynamic initialization code to a module-level <code>__init__</code>
        function.</p>
<h4>    Module-level <code>__init__()</code> Functions</h4>
<p>        The last thing <code>setupModule()</code> does before returning, is to check for a
        module-level <code>__init__()</code> function, and call it with no arguments, if
        it exists.  This allows you to do any dynamic initialization operations
        (such as modifying or resetting global mutables) <em>after</em> inheritance
        has taken effect.  As with any other function defined in the module,
        <code>__proceed__</code> refers to the previous (i.e. preceding base module)
        definition of the function or <code>None</code>.  This lets you can chain to your
        predecessors' initialization code, if needed/desired.</p>
<p>        Note, by the way, that if you have an <code>if __name__=="__main__"</code> block
        in your module, it would probably be best if you move it inside the
        <code>__init__()</code> function, as this ensures that it will not be run
        repeatedly if you do not wish it to be.  It will also allow other
        modules to inherit that code and wrap around it, if they so desire.</p>
<h4>    Package Inheritance</h4>
<p>        Packages (i.e. <code>__init__</code> modules) can also set <code>__bases__</code> and
        call <code>setupModule()</code>.  Their package <code>__path__</code> will be extended
        to include the <code>__path__</code> contents of their <code>__bases__</code>, in an
        MRO-like order.  This means that to derive a package from another,
        you do not need to create a separate inheriting module for every
        individual module or subpackage, only those that you wish to make
        modifications to.  If package <code>foo</code> contains modules <code>foo.bar</code>
        and <code>foo.baz</code>, and you want your <code>spam</code> package to derive from
        <code>foo</code>, you need only create a <code>spam/__init__.py</code> that contains:
<pre>
            import foo
            __bases__ = foo,

            # ...

            from peak.api import config
            config.setupModule()
</pre>
</p>
<p>        At this point, <code>spam.baz</code> or <code>spam.bar</code> will automatically be
        importable, based on the <code>foo</code> versions of their code.  This
        will work even if the <code>foo</code> versions don't call <code>setupModule()</code>,
        although in that case you won't be able to override their contents.</p>
<p>        To override a module within the <code>spam</code> package, just create it,
        and use module inheritance to specify the base in the original
        package.  For example, you can extend <code>foo.bar</code> by creating
        <code>spam.bar</code> as follows:
<pre>
            import foo.bar
            __bases__ = foo.bar,

            # ...

            from peak.api import config
            config.setupModule()
</pre>
</p>
<h4>    Limitations of Package Inheritance</h4>
<p>        Because &quot;package inheritance&quot; is effectively just a <code>__path__</code> hack,
        it is really only good for &quot;single inheritance&quot;.  Python will not
        automatically merge the modules or packages found on a package's
        <code>__path__</code>.  So if you need multiple inheritance, you will need
        to create a module or subpackage for each module or subpackage
        that exists in more than one base package, and explicitly specify
        the right <code>__bases__</code> for it.  If a module or subpackage only
        appears in one base, however, and you have nothing to add to it,
        you can omit it from the inheriting package.</p>
<h4>    Using Relative Imports in Packages</h4>
<p>        If you want to extend a package, it's important to use only
        relative imports.  This is because the code of a module
        is executed as-is in the derived module.  If you do an
        absolute import, e.g. <code>import foo.baz</code> in package <code>foo.bar</code>,
        then <code>spam.bar</code> will still import <code>foo.baz</code>, not <code>spam.baz</code>.
        It's better to <code>import baz</code> for an item in the same package,
        or use <code>peak.utils.imports.lazyModule</code> like this:
<pre>
            from peak.utils.imports import lazyModule
            baz = lazyModule(__name__, 'baz')
</pre>
</p>
<p>        While this is more verbose in the simple case, it works for
        more complex relative paths than Python allows; for example
        you can do this:
<pre>
            eggs = lazyModule(__name__, '../ni/eggs')
</pre>
</p>
<p>        which isn't possible with a regular <code>import</code> statement.</p>
<h4>    Import Paths</h4>
<p>        To make using relative imports easier, <code>__bases__</code> can include
        &quot;/&quot;-separated relative path strings instead of modules, e.g.:
<pre>
            __bases__ = '../../foo/bar',
</pre>
</p>
<p>        A / at the beginning of the path makes it absolute, so <code>/foo/bar</code>
        would also work.</p>
<h4>    To-do Items</h4>

<ul>
<li><p>The simulator should issue warnings for a variety of questionable
          situations, such as...
<ul>
<li><p>Code matching the following pattern, which doesn't do what it looks
            like it does, and should probably be considered a "serious order
            disagreement":
<pre>
            BaseModule:

                class Foo: ...

                class Bar: ...

            DerivedModule:

                class Bar: ...

                class Foo(Bar): ...
</pre>
</p></li>

</ul>
</p></li>
<li><p>This docstring is woefully inadequate to describe all the interesting
          subtleties of module inheritance; a tutorial is really needed.  But
          there <em>does</em> need to be a reference-style explanation as well, that
          describes the precise semantics of interpretation for assignments,
          <code>def</code>, and <code>class</code>, in modules running under simulator control.</p></li>
<li><p>Allow <code>declareModule()</code> to bootstrap non-existent modules; this might
          let us create &quot;virtual packages&quot; made by assembling other packages
          and modules.</p></li>
<li><p>Need a strategy for handling &quot;del&quot; operations; they are currently
          untrapped.  This might be okay under most circumstances, but need to
          consider edge cases.</p></li>
<li><p><code>makeClass()</code> should probably become part of the core API, where
          it can be used to resolve __metaclass__ conflicts during the first
          pass of importing a module (prior to running <code>setupModule()</code>)</p></li>

</ul>
<table border="0" cellpadding="5" cellspacing="0" width="100%">

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="Imported modules">Imported modules</a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        
<b>from</b> <a href="http://www.python.org/doc/current/lib/module-__future__.html">__future__</a> <b>import</b> generators<br>
<b>from</b> peak.util.Code <b>import</b> *, BUILD_CLASS, STORE_NAME, MAKE_CLOSURE, MAKE_FUNCTION, LOAD_CONST, STORE_GLOBAL, CALL_FUNCTION, IMPORT_STAR, IMPORT_NAME, JUMP_ABSOLUTE, POP_TOP, ROT_FOUR, LOAD_ATTR, LOAD_GLOBAL, ROT_TWO, LOAD_LOCALS, STORE_SLICE, DELETE_SLICE, STORE_ATTR, STORE_SUBSCR, DELETE_SUBSCR, DELETE_ATTR, DELETE_NAME, DELETE_GLOBAL<br>
<b>from</b> peak.util.EigenData <b>import</b> AlreadyRead<br>
<b>from</b> peak.util.Meta <b>import</b> makeClass<br>
<b>from</b> peak.util._Code <b>import</b> codeIndex<br>
<b>from</b> peak.util.imports <b>import</b> lazyModule, joinPath, getModuleHooks<br>
<b>from</b> protocols.advice <b>import</b> isClassAdvisor<br>
<b>import</b> <a href="http://www.python.org/doc/current/lib/module-sys.html">sys</a><br>
<b>from</b> <a href="http://www.python.org/doc/current/lib/module-types.html">types</a> <b>import</b> ModuleType<br>
<b>from</b> <a href="http://www.python.org/doc/current/lib/module-warnings.html">warnings</a> <b>import</b> warn, warn_explicit<br>

</td></tr>

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="Functions">Functions</a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        

            <table border="0" cellspacing="2" cellpadding="2" width="100%">
              <tr>
            <td align="LEFT" valign="TOP">
<a href="#buildModule">buildModule</a><br>
<a href="#declareModule">declareModule</a><br>
<a href="#getCodeListForModule">getCodeListForModule</a><br>
<a href="#getLegacyCode">getLegacyCode</a><br>
<a href="#moduleBases">moduleBases</a><br>
</td>
<td align="LEFT" valign="TOP">
<a href="#patchModule">patchModule</a><br>
<a href="#prepForSimulation">prepForSimulation</a><br>
<a href="#setupModule">setupModule</a><br>
<a href="#setupObject">setupObject</a><br>
<a href="#toBases">toBases</a><br>
</td>
</tr>
            </table>
            

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="buildModule"></a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">buildModule&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        <font color="#000088"><pre>
buildModule ( module,  code=None )

</pre></font>


        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="declareModule"></a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">declareModule&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        <font color="#000088"><pre>
declareModule (
        name,
        relativePath=None,
        bases=(),
        patches=(),
        )

</pre></font>

<h3>Package Inheritance Shortcut and Third-party Patches</h3>
<p>    This function lets you &quot;pre-declare&quot; that a module should have
    some set of bases or &quot;patch modules&quot; applied to it.  This lets
    you work around the single-inheritance limitation of package
    inheritance, and it also lets you apply &quot;patch modules&quot; to
    third-party code that doesn't call <code>setupModule()</code>.</p>
<p>    To use this, you must call it <em>before</em> the module has been
    imported, even lazily.  You can call it again as many times
    as you like, as long as the base and patch lists remain the
    same for a given module.  Also note that the module must <em>exist</em>;
    that is, there must be some Python-findable source or bytecode
    for the specified module.  It can be &quot;inherited&quot; via package
    inheritance from its containing package's base package; you just
    can't make up a phony module name and have it work.  (This limitation
    might get lifted later, if it turns out to be useful.)</p>
<p>    <code>bases</code> are placed in the target module's <code>__bases__</code>, <em>after</em>
    any bases declared in the package.  <code>patches</code> are applied as
    though they were the first modules to call <code>patchModule()</code>.
    So the overall &quot;MRO&quot; for the resulting module looks like this:
<ol>
<li><p> patches by modules calling <code>patchModule()</code></p></li>
<li><p> modules specified by <code>declareModule(patches=)</code></p></li>
<li><p> the module itself</p></li>
<li><p> any <code>__bases__</code> declared by the module</p></li>
<li><p> base modules supplied by <code>declareModule(bases=)</code></p></li>

</ol>
</p>
<p>    Note that both <code>bases</code> and <code>patches</code> may be modules,
    relative paths to modules (relative to the declared module,
    <em>not</em> the <code>name</code> parameter), or tuples of modules or paths.</p>
<p>    Using <code>declareModule()</code> makes it easier to do multiple inheritance
    with packages.  For example, suppose you have packages <code>square</code>
    and <code>circle</code>, and want to make a package <code>curvyBox</code> that inherits
    from both.</p>
<p>    Further suppose that the <code>square</code> package contains a <code>square.rect</code>
    module, and a <code>square.fill</code> module, and <code>circle</code> contains a
    <code>circle.curve</code> module, and a <code>circle.fill</code> module.  Because of
    the way the Python package <code>__path__</code> attribute works, package
    inheritance won't combine the <code>.fill</code> modules; instead, it will
    pick the first <code>.fill</code> module found.</p>
<p>    To solve this, we could create a <code>curvyBox.fill</code> module that inherited
    from both <code>square.fill</code> and <code>circle.fill</code>.  But if there are many such
    modules or subpackages, and they will be empty but for <code>__bases__</code>, we
    can use <code>declareModule()</code> to avoid having to create individual
    subdirectories and <code>.py</code> files.</p>
<p>    This can be as simple as creating <code>curvyBox.py</code> (or
    <code>curvybox/__init__.py</code>), and writing this code:
<pre>
        from peak.api import *

        __bases__ = '../square', '../circle'

        config.declareModule(__name__, 'fill',
            bases = ('../../circle/fill',)  # relative to 'curvyBox.fill'
        )

        config.setupModule()
</pre>
</p>
<p>    This will add <code>circle.fill</code> to the <code>__bases__</code> of <code>curvyBox.fill</code> (which
    will be the inherited <code>square.fill</code> module.</p>
<p>    Another usage of <code>declareModule()</code> is to patch a third-party module:
<pre>
        import my_additions
        config.declareModule('third.party.module', patches=(my_additions,))
</pre>
</p>
<table border="0" cellpadding="5" cellspacing="0" width="100%">

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="Exceptions">Exceptions</a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        
SpecificationError(( "%s has already been declared differently" % name ), patches, declarations [ name ] )<br>

</td></tr>
</table>

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="getCodeListForModule"></a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">getCodeListForModule&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        <font color="#000088"><pre>
getCodeListForModule ( module,  code=None )

</pre></font>

<table border="0" cellpadding="5" cellspacing="0" width="100%">

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="Exceptions">Exceptions</a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        
TypeError("%s is not a module in %s __bases__" %( baseModule, name ) )<br>

</td></tr>
</table>

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="getLegacyCode"></a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">getLegacyCode&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        <font color="#000088"><pre>
getLegacyCode ( module )

</pre></font>

<table border="0" cellpadding="5" cellspacing="0" width="100%">

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="Exceptions">Exceptions</a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        
AssertionError( "Bad magic for %s" % file )<br>
AssertionError( "Can't retrieve code for %s" % module )<br>

</td></tr>
</table>

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="moduleBases"></a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">moduleBases&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        <font color="#000088"><pre>
moduleBases ( module,  name='' )

</pre></font>


        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="patchModule"></a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">patchModule&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        <font color="#000088"><pre>
patchModule ( moduleName )

</pre></font>

<h3>&quot;Patch&quot; a module - like a runtime (aka &quot;monkey&quot;) patch, only better</h3>
<p>        Usage:
<pre>
            from peak.api import config

            # ... body of module

            config.patchModule('moduleToPatch')

    'patchModule()' works much like 'setupModule()'.  The main difference
    is that it applies the current module as a patch to the supplied module
    name.  The module to be patched must not have been imported yet, and it
    must call 'setupModule()'.  The result will be as though the patched
    module had been replaced with a derived module, using the standard module
    inheritance rules to derive the new module.

    Note that more than one patching module may patch a single target module,
    in which case the order of importing is significant.  Patch modules
    imported later take precedence over those imported earlier.  (The target
    module must always be imported last.)

    Patch modules may patch other patch modules, but there is little point
    to doing this, since both patch modules will still have to be explicitly
    imported before their mutual target for the patches to take effect.
</pre>
</p>
<table border="0" cellpadding="5" cellspacing="0" width="100%">

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="Exceptions">Exceptions</a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        
AlreadyRead( "%s is already imported and cannot be patched" % moduleName )<br>
SpecificationError( "Patch modules cannot use '__bases__'" )<br>

</td></tr>
</table>

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="prepForSimulation"></a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">prepForSimulation&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        <font color="#000088"><pre>
prepForSimulation (
        code,
        path='',
        depth=0,
        )

</pre></font>

<table border="0" cellpadding="5" cellspacing="0" width="100%">

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="Exceptions">Exceptions</a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        
AssertionError("Unrecognized 'import *' at line %(line)d" % locals() )<br>
AssertionError("Unrecognized class %(qname)s at line %(line)d" % locals() )<br>

</td></tr>
</table>

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="setupModule"></a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">setupModule&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        <font color="#000088"><pre>
setupModule ()

</pre></font>

<h3>setupModule() - Build module, w/patches and inheritance</h3>
<p>    <code>setupModule()</code> should be called only at the very end of a module's
    code.  This is because any code which follows <code>setupModule()</code> will be
    executed twice.  (Actually, the code before <code>setupModule()</code> gets
    executed twice, also, but the module dictionary is reset in between,
    so its execution is cleaner.)</p>

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="setupObject"></a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">setupObject&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        <font color="#000088"><pre>
setupObject ( obj,  **attrs )

</pre></font>

<p>Set attributes without overwriting values defined in a derived module</p>

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="toBases"></a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">toBases&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        <font color="#000088"><pre>
toBases ( bases,  name='' )

</pre></font>

</td></tr>

        <tr>
            <th bgcolor="#99ccff"
                rowspan="2"
                valign="top"
                align="left"
                width="20%"
                >
                <font color="#000000">
                  <a name="Classes">Classes</a>&nbsp;
                </font>
            </th>
            <th bgcolor="#99ccff"
                valign="top"
                align="left"
                width="80%"
                >
                <font color="#000000">&nbsp;</font>
            </th>
        </tr>
        <tr>
        <td>
        
<table border="0" cellpadding="3" cellspacing="0">
<tr><td valign="top" align="left"><p><a href="modules/ModuleInheritanceWarning.html">ModuleInheritanceWarning</a></p></td><td valign="top" align="left"></td></tr>
<tr><td valign="top" align="left"><p><a href="modules/Simulator.html">Simulator</a></p></td><td valign="top" align="left"></td></tr>
<tr><td valign="top" align="left"><p><a href="modules/SpecificationError.html">SpecificationError</a></p></td><td valign="top" align="left"></td></tr>
</table>
</td></tr>
</td></tr>
</table>

        </td>
        </tr>
        </table>

        <hr>

        <p><i><a href="../../../index.html">Table of Contents</a></i></p>

        <font size="-2"><i>This document was automatically generated
        on Tue Feb 17 19:55:40 2004 by
        <a href="http://happydoc.sourceforge.net">HappyDoc</a> version
        2.1</i></font>
        
        </body>
        </html>
        